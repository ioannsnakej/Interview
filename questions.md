# Вопросы собеседований на позицию DevOps-инженера
<details>
  <summary>Linux</summary>

  ### 1. Что такое load average? Что показывает эта метрика? Почему load average состоит из трёх значений?
  <details>
    <summary>Ответ</summary>

  ***LA (load average - средняя нагрузка системы)*** - параметр, определяющий среднее количество процессов, которые:
      
  - выполняются прямо сейчас (в состоянии running),
  - либо ожидают доступа к CPU или диску (в состоянии uninterruptible sleep).
      
  Значения показываются для последних 1, 5 и 15 минут. Это позволяет:

  - Оценить динамику нагрузки. Значения помогают понять, как процессы в системе нагружают CPU с течением времени.
  - Учесть не только активные процессы, но и те, которые ждут своей очереди. Это позволяет получить более полное представление о загруженности системы.
  - Учесть процессы, которые ожидают завершения операций ввода-вывода. Эти процессы могут значительно влиять на производительность системы, даже если они не занимают CPU напрямую. 
      
  #### Как посмотреть LA:
  - uptime
  - cat /proc/loadavg
  #### Как интерпритировать:
  Главное правило:
  **Сравнивайте load average с количеством ядер процессора.**
  
  Посмотреть количество ядер можно командой:
      
    nproc
  **Пример:**
  Если у вас N ядра, то:

  - load = N — система загружена на 100%
  - load < N — запас по ресурсам есть
  - load > N — ядрам не хватает времени, процессы начинают ждать
      
  #### Высокое значение не всегда значит, что процессор "зашит".
  На нагрузку влияют и другие факторы:

  |Причина|Описание|
  |-|-|
  |CPU-bound процессы|Программы, активно использующие процессор (компиляция, шифрование, вычисления).|
  |I/O wait | Задержки из-за медленного диска или файловой системы — процессы ждут завершения операций чтения/записи.|
  |Недостаток RAM | Когда система начинает использовать swap — растёт задержка и load.|
  |Блокировка ресурсов | Процессы ждут освобождения файлов, сокетов или блокировок БД.|
  |Много фоновых задач | Cron, systemd-службы, резервные копии, индексация и т.п.|
  [!NOTE]
  Также влияние на расчета LA оказывает: 
  1. Технология Hyper-Threading, которая делит одно физическое ядро на 2 логических 
  2. Технология Turbo Bust, которая позволяет разгонять тактовую частоту процессора и работать на частоте выше заявленной, т.е. выше номинальной частоты (время на обработку одной задачи уменьшается).
  #### Как диагностировать:

  - htop покажет загруженность CPU и RAM, а также количество процессов в состоянии D (ожидание I/O)
  - iotop — отследит нагрузку на диск
  - iftop — покажет текущий сетевой трафик
  </details>

  ### 2. Что такое OOM killer? Для чего нужен? Как работает?
  <details>
    <summary>Ответ</summary>
    
  ***OOM Killer*** — механизм ядра Linux, который при исчерпании доступной памяти принудительно завершает отдельные процессы на сервере для освобождения RAM. Освободившаяся память передается ядру ОС, а после перенаправляется тому процессу, которому ее было недостаточно. Сообщение об этом отображается в /var/log/syslog (Debian/Ubuntu) или /var/log/messages (Centos/RHell).

  OOM Killer сканирует запущенные процессы и назначает каждому из них *oom_score* — показатель, который представляет его «вредность» или вероятность завершения. Некоторые факторы, на основе которых рассчитывается oom_score:

  - использование памяти (процессы, потребляющие больше памяти, получают более высокие оценки);
  - время работы процесса (более длительные процессы получают более низкие оценки);
  - привилегии root (процессы, запущенные под root, получают менее низкие оценки);
  - значение nice (процессы с более низким приоритетом (высокими значениями nice) получают более высокие оценки);
  - ручная настройка через oom_score_adj (настраивает вероятность завершения процесса).

  В первую очередь будут завершены недавно запущенные пользовательские процессы, которые требуют большого объема памяти и/или имеют множество дочерних процессов; в последнюю очередь будут завершаться системные процессы пользователя root, запущенные значительное время назад.
  В связи с тем, что OOM killer «убивает» процессы с помощью SIGKILL, что не дает возможности корректного завершения процессов, сохранения данных и пр., частое срабатывание этого механизма может приводить к серьезным последствиям в работе системе.

  #### Что делать:

  - Провести анализ работы сервера, баз данных, сайтов и тд с целью последующей оптимизации, чтобы устранить причину проблемы.
  - Если сервер уже оптимизирован, но памяти не хватает, то стоит задуматься о увеличении  объема RAM.
  - Также есть возможность установить приоритет определенному процессу, чтобы запретить OOM killer его завершать. Значение приоритета хранится в файле /proc/$PID/oom_adj. Для установки приоритета необходимо узнать PID конкретного процесса, после чего воспользоваться командой:
        
        echo -17 > /proc/PID_процесса/oom_adj

  Устанавливаемый приоритет в данном случае — -17. Более безопасный вариант — использовать приоритет -15. В этом случае процесс будет одним из последних, которые OOM killer завершит, но при этом отсутствует полный запрет на завершение, который в критических ситуациях может привести к kernel panic.
  </details>

</details>
<details>
<summary>k8s</summary>

  ### 1. Что такое kubernetes?
  <details>
    <summary>Ответ</summary>
      
  ***Kubernetes*** - открытое программное обеспечение для оркестрации контейнеризированных приложений — автоматизации их развёртывания, масштабирования и координации в условиях кластера.
  
  Он решает следующие задачи:

  - деплоймент — поднимает новые экземпляры приложения;
  - самовосстановление — следит за приложением, если упало, автоматически перезапускает;
  - управление — контролирует жизненный цикл приложения;
  - масштабирование — добавляет или уменьшает количество экземпляров приложения, в зависимости от нагрузки;
  - балансировка трафика — распределяет нагрузку, по экземплярам приложений.
  </details>
</details>